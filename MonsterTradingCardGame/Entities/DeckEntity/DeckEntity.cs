using MasterTradingCardGame.Database;
using MonsterTradingCardGame.Infrastructure.Authentication;
using MonsterTradingCardGame.Models;
using MonsterTradingCardGame.Repositories;
using Npgsql;
using RestServer.WebServer.CommunicationObjects;
using RestServer.WebServer.Infrastructure;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MonsterTradingCardGame.Entities.DeckEntity
{
    public sealed class DeckEntity
    {
        public void AutoGenerateDeck(RequestContext requestContext, string name, int cardCountPerDeck)
        {
            using (NpgsqlConnection connection = database.CreateAndOpenConnection())
            using (NpgsqlTransaction transaction = connection.BeginTransaction())
            {
                UserSession session = CookieAuthenticationModule.GetUserSessionFromRequest(requestContext, transaction);

                int createdDeckId = deckRepository.InsertDeck(session.UserID, name, transaction);

                IEnumerable<(CardLibraryItem item, int usages)> cardLibrary = cardLibraryRepository
                    .GetCardLibraryItemsByUserID(session.UserID, transaction)
                    .Select(i => (item: i, usages: 0));

                int cardsInLibrary = cardLibrary.Sum(l => l.item.Quantity);

                if (cardsInLibrary < cardCountPerDeck)
                    throw new NotEnoughCardsInLibraryException(
                        $"Cannot Build Deck. Library is to small. Number of Cards in Library: {cardsInLibrary}. " +
                        $"Number Cards needed for Decks: {cardCountPerDeck}.");

                IEnumerable<int> bestPicks = GetBestPicks(cardCountPerDeck, cardLibrary);

                Assert.That(
                    bestPicks.Count() == cardCountPerDeck,
                    $"Cards in {nameof(bestPicks)}: {bestPicks.Count()}. " +
                    $"{cardCountPerDeck} are needed to Build a valid Deck."
                );

                foreach (int cardID in bestPicks)
                    deckRepository.AssignCardToDeck(createdDeckId, cardID, transaction);

                transaction.Commit();
            }
        }

        private IEnumerable<int> GetBestPicks(int cardCountPerDeck, IEnumerable<(CardLibraryItem item, int usages)> cardLibrary)
        {
            List<int> bestPicks = new List<int>();
            int maxPossibleCardsWithDifferentElement = cardCountPerDeck / Enum.GetNames(typeof(ElementType)).Length;

            // Try to get the maximum number of strongest card from each possible element.
            IEnumerable<IGrouping<ElementType, (CardLibraryItem item, int usages)>> elementGroupings = cardLibrary.GroupBy(l => l.item.Element);

            for (int i = 0; i < maxPossibleCardsWithDifferentElement; i++)
            {
                foreach (IGrouping<ElementType, (CardLibraryItem item, int usages)> grouping in elementGroupings)
                {
                    (CardLibraryItem item, int usages) strongestCardForCurrentElement = grouping
                        .OrderByDescending(g => g.item.AttackPoints)
                        .First();

                    if (strongestCardForCurrentElement.item.Quantity > strongestCardForCurrentElement.usages)
                    {
                        ++strongestCardForCurrentElement.usages;
                        bestPicks.Add(strongestCardForCurrentElement.item.Card_ID);
                    }
                }
            }

            // For the remaining places just get the strongest cards possible
            int remainingPlaces = cardCountPerDeck - bestPicks.Count;

            for (int i = 0; i < remainingPlaces; i++)
            {
                IEnumerable<(CardLibraryItem item, int usages)> bestPossiblePicks = cardLibrary
                    .Where(l => l.item.Quantity > l.usages);

                Assert.That(bestPossiblePicks.Count() >= remainingPlaces, $"bestPossiblePicks.Count() must be larger or equal to {nameof(remainingPlaces)}");

                (CardLibraryItem item, int usages) bestPossiblePick = bestPossiblePicks
                    .OrderByDescending(l => l.item.AttackPoints)
                    .First();

                ++bestPossiblePick.usages;
                bestPicks.Add(bestPossiblePick.item.Card_ID);
            }

            return bestPicks;
        }

        private readonly DeckRepository deckRepository = new DeckRepository(database);
        private readonly CardLibraryRepository cardLibraryRepository = new CardLibraryRepository(database);

        private static readonly PostgreSqlDatabase database =
            new PostgreSqlDatabase("Host=localhost;Port=5433;Username=postgres;Password=Badger123!;Database=MonsterTradingCardGame");
    }
}
